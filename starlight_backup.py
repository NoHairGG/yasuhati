import aubio
import audioop
import math
import numpy
import os
import pyaudio
import pygame as pg
import random
import threading
from typing import List

# some global variable
main_dir = os.path.split(os.path.abspath(__file__))[0]

def senseHAT_event():
    return None

def load_image(file):
    """loads an image, prepares it for play"""
    file = os.path.join(main_dir, "data", file)
    try:
        surface = pg.image.load(file)
    except pg.error:
        raise SystemExit(f'Could not load image "{file}" {pg.get_error()}')
    return surface.convert_alpha()

def load_sound(file):
    """because pygame can be compiled without mixer."""
    if not pg.mixer:
        return None
    file = os.path.join(main_dir, "data", file)
    try:
        sound = pg.mixer.Sound(file)
        return sound
    except pg.error:
        print(f"Warning, unable to load, {file}")
    return None

def microphone_setup():
    pa = pyaudio.PyAudio()
    stream = pa.open(format = pyaudio.paFloat32,channels=1,rate=44100,input_device_index=1,input=True,frames_per_buffer=1024)
    pDetection = aubio.pitch("default", 4096, 1024, 44100)
    pDetection.set_unit("Hz")
    pDetection.set_silence(-40)
    return pa, stream, pDetection

class Obstacle(pg.sprite.Sprite):
    """Player needs to get over it, XD"""
    speed = -5
    images: List[pg.Surface] = []

    def __init__(self, *groups):
        pg.sprite.Sprite.__init__(self, *groups)
        self.image = self.images[0]
        self.rect = self.image.get_rect(center=(640, random.random()*360))

    def update(self):
        """called every loop"""
        self.rect.move_ip(self.speed, 0)
        if self.rect.right <= 0:
            self.kill()

class Hadouken(pg.sprite.Sprite):
    """Hadouken will be generated by player, should be cool"""
    speed = 20
    images: List[pg.Surface] = []
    
    def __init__(self, pos, *groups):
        pg.sprite.Sprite.__init__(self, *groups)
        self.image = self.images[0]
        self.rect = self.image.get_rect(center=pos)
        
    def update(self):
        """called every loop"""
        self.rect.move_ip(self.speed, 0)
        if self.rect.left >= 720:
            self.kill()

class Explosion(pg.sprite.Sprite):
    """Just an explosion"""
    total_frame = 12
    cycle = 3
    images: List[pg.Surface] = []

    def __init__(self, actor, *groups):
        pg.sprite.Sprite.__init__(self, *groups)
        self.image = self.images[0]
        self.rect = self.image.get_rect(center=actor.rect.center)
        self.life = self.total_frame
        
    def update(self):
        """Show the animation frame by frame"""
        self.life = self.life - 1
        self.image = self.images[self.life // self.cycle % 2]
        if self.life <= 0:
            self.kill()
    
class Player(pg.sprite.Sprite):
    """0 for idle, 1 for moving, 2 for jumping"""
    hadouken_offset = 0
    images: List[pg.Surface] = []

    def __init__(self, *groups):
        pg.sprite.Sprite.__init__(self, *groups)
        self.image = self.images[0]
        self.rect = self.image.get_rect(midbottom=SCREENRECT.midbottom)
        self.reloading = 0
        self.origtop = self.rect.top
        self.facing = -1
        self.moving = False
        # print("hello madafaka")

    def rest(self):
        self.image = self.images[0]
        self.rect = self.image.get_rect(midbottom=SCREENRECT.midbottom)
        self.moving = False
        #print("resting")

    def move(self):
        """actually move the background"""
        self.image = self.images[1]
        self.rect = self.image.get_rect(midbottom=SCREENRECT.midbottom)
        self.moving = True
        print("moving")
        
    def jump(self):
        """show state change"""
        self.image = self.images[2]
        self.moving = True
        print("jumping")
        
    def jump_volume(self, value):
        """move upward and downward"""
        self.image = self.images[2]
        self.rect.top = 324 - value
        self.moving = True
        print("jumping")
        
    def groups(self):
        # pos = self.facing * self.hadouken_offset + self.rect.centerx
        pos = self.rect.centerx
        # return pos, self.rect.right
        return pos, self.rect.centery

SCREENRECT = pg.Rect(0, 0, 640, 360)
OBSTACLE_RELOAD_FRAME = 60

def main(winstyle=0):
    """audio input setup"""
    pa, stream, pDetection = microphone_setup()

    """program flow"""
    scroll = 0
    obstacle_reload = OBSTACLE_RELOAD_FRAME
    running = True
    pg.init()
    while running:
        for event in pg.event.get():
            if event.type == pg.QUIT:
                running = False
        """display setup"""
        winstyle = 0  #full screen
        bestdepth = pg.display.mode_ok(SCREENRECT.size, winstyle, 32)
        screen = pg.display.set_mode(SCREENRECT.size, winstyle, bestdepth)
        # pg.display.flip()
        """resource initiazation after screen setup"""
        Player.images = [load_image(im) for im in ("idle.jpg", "move.jpg", "jump.jpg")]
        Hadouken.images = [load_image("hadouken-removebg-preview.png")]
        Hadouken.images[0] = pg.transform.scale(Hadouken.images[0] , (32,32))
        Obstacle.images = [load_image("wall.bmp")]
        # create the background, tile the background image if needed
        bgdtile = load_image("yasuhati_bg2.bmp")
        # background = pg.Surface(SCREENRECT.size)
        # for x in range(0 , SCREENRECT.width, bgdtile.get_width()):
        #     background.blit(bgdtile, (x, 0))
        # screen.blit(bgdtile, (0, 0))
        tiles = math.ceil(720 / bgdtile.get_width()) + 1
        pg.display.update()
        """Sound effects"""
        hadouken_sound = load_sound("hadouken.mp3")
        """Initialize Game Groups"""
        hadouken = pg.sprite.Group()
        obstacles = pg.sprite.Group()
        """initial obstacle reload parameter"""
        clock = pg.time.Clock()
        """set player """
        all = pg.sprite.RenderUpdates()
        player = Player(all)
        last_pitch = 0.0
        while player.alive():
            clock.tick(30)
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    return
            keystate = pg.key.get_pressed()
            # jump = keystate[pg.K_SPACE]
            command = keystate[pg.K_p]
            # print(command)
            if not player.reloading and command:
                Hadouken(player.groups(), hadouken, all)
                hadouken_sound.play()
            player.reloading = command
            # check volume
            raws=stream.read(1024, exception_on_overflow = False)
            samples=numpy.frombuffer(raws, dtype=numpy.float32)
            numpy.set_printoptions(threshold=numpy.inf)
            rms = audioop.rms(samples, 2)
            pitch = pDetection(samples)[0]
            # print(rms)
            if (pitch - last_pitch) > 400:
                pitch = last_pitch
            else:
                last_pitch = pitch
            if pitch > 200:
                adjusted = pitch - 200
                player.jump_volume(adjusted)
                print(pitch)
            elif pitch > 10:
                player.move()
                print(pitch)
            else:
                player.rest()
            # scroll da background
            i = 0
            if (player.moving):
                # Create new obstacle
                if obstacle_reload:
                    obstacle_reload = obstacle_reload - 1
                elif not int(random.random() * 20):
                    Obstacle(obstacles, all)
                    obstacle_reload =  OBSTACLE_RELOAD_FRAME
                while(i < tiles): 
                    screen.blit(bgdtile, (bgdtile.get_width()*i + scroll, 0)) 
                    i += 1
                scroll -= 6
                if abs(scroll) > bgdtile.get_width():
                    scroll = 0
                # print(scroll)
            pg.display.flip()
            # clear/erase the last drawn sprites
            all.clear(screen, bgdtile)
            # update all the sprites
            all.update()
            dirty = all.draw(screen)
            pg.display.update(dirty) 
        # draw the elements

# call the "main" function
if __name__ == "__main__":
    main()
    pg.quit()
